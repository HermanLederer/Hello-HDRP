#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Filtering.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/BloomCommon.hlsl"

#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel UpsampleUnity
#pragma kernel BlurUnity
#pragma kernel HBlur
#pragma kernel VBlur

TEXTURE2D_X(_InputTexture);
RW_TEXTURE2D_X(float3, _OutputTexture);
int _BlurSteps;
float _BlurStepSize;

SAMPLER(sampler_LinearClamp);

//CBUFFER_START(cb0)
    //float4 _Params;                 // x: scatter, yzw: unused
    float4 _BloomBicubicParams;     // xy: low src size, zw: low src texel size
    float4 _TexelSize;              // xy; high src size, zw: high src texel size
//CBUFFER_END

#define GROUP_SIZE 8

float random(float2 uv)
{
	return frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453123);
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void UpsampleUnity(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
    PositionInputs posInputs = GetPositionInput(float2(dispatchThreadId.xy), _TexelSize.zw, uint2(GROUP_SIZE, GROUP_SIZE));
    // float2 uv = ClampAndScaleUVForBilinear(posInputs.positionNDC, _TexelSize.zw);
    float2 uv = posInputs.positionNDC;

	//positionLeft = float2(positionSS.x - 1, positionSS.y);
	//positionRight = float2(positionSS.x + 1, positionSS.y);

	// Origin
	// Right (x + 1)
	// Down (y + 1)
	//float3 outColor = LOAD_TEXTURE2D_X(_InputTexture, positionSS * _TexelSize.z).xyz;
	//float totalWeight = 1;

	//float3 outColorR = LOAD_TEXTURE2D_X(_InputTexture, positionSS * _TexelSize.z + float2(1, 0)).xyz;
	//float3 outColorD = LOAD_TEXTURE2D_X(_InputTexture, positionSS * _TexelSize.z + float2(0, 1)).xyz;
	//float tx = (positionSS.x % _TexelSize.x) / 4;
	//float ty = (positionSS.y % _TexelSize.y) / 4;

	//_OutputTexture[COORD_TEXTURE2D_X(uv)] = lerp(outColor, outColorR, tx);
	//_OutputTexture[COORD_TEXTURE2D_X(uv)] = outColor;
	//_OutputTexture[COORD_TEXTURE2D_X(posInputs.positionSS)] = random(uv);



    // Unity upsampling code
    //float3 lowRes = SAMPLE_TEXTURE2D_X_LOD(_InputTexture, sampler_LinearClamp, uv, 0.0).xyz;

    //float2 maxCoord = (1.0f - _TexelSize.zw) * _RTHandleScale.xy;
    //float3 lowRes = SampleTexture2DBicubic(TEXTURE2D_X_ARGS(_InputTexture, sampler_LinearClamp), uv, _BloomBicubicParams, maxCoord, unity_StereoEyeIndex).xyz;

    float3 output = LOAD_TEXTURE2D_X(_InputTexture, uv).xyz;

    // Guard bands
    //output *= all(dispatchThreadId.xy < uint2(_TexelSize.xy));

    //output += float3(1, 1, 1);
    _OutputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = output;
}

// 16x16 pixels with an 8x8 center that we will be blurring writing out. Each uint is two color
// channels packed together.
// The reason for separating channels is to reduce bank conflicts in the local data memory
// controller. A large stride will cause more threads to collide on the same memory bank.
groupshared uint gs_cacheR[128];
groupshared uint gs_cacheG[128];
groupshared uint gs_cacheB[128];

float3 BlurPixels(float3 a, float3 b, float3 c, float3 d, float3 e, float3 f, float3 g, float3 h, float3 i)
{
    return 0.27343750 * (e    )
         + 0.21875000 * (d + f)
         + 0.10937500 * (c + g)
         + 0.03125000 * (b + h)
         + 0.00390625 * (a + i);
}

void Store2Pixels(uint index, float3 pixel1, float3 pixel2)
{
    gs_cacheR[index] = f32tof16(pixel1.r) | f32tof16(pixel2.r) << 16;
    gs_cacheG[index] = f32tof16(pixel1.g) | f32tof16(pixel2.g) << 16;
    gs_cacheB[index] = f32tof16(pixel1.b) | f32tof16(pixel2.b) << 16;
}

void Load2Pixels(uint index, out float3 pixel1, out float3 pixel2)
{
    uint rr = gs_cacheR[index];
    uint gg = gs_cacheG[index];
    uint bb = gs_cacheB[index];
    pixel1 = float3(f16tof32(rr      ), f16tof32(gg      ), f16tof32(bb      ));
    pixel2 = float3(f16tof32(rr >> 16), f16tof32(gg >> 16), f16tof32(bb >> 16));
}

void Store1Pixel(uint index, float3 pixel)
{
    gs_cacheR[index] = asuint(pixel.r);
    gs_cacheG[index] = asuint(pixel.g);
    gs_cacheB[index] = asuint(pixel.b);
}

void Load1Pixel(uint index, out float3 pixel)
{
    pixel = asfloat(uint3(gs_cacheR[index], gs_cacheG[index], gs_cacheB[index]));
}

// Blur two pixels horizontally. This reduces LDS reads and pixel unpacking.
void BlurHorizontally(uint outIndex, uint leftMostIndex)
{
    float3 s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
    Load2Pixels(leftMostIndex + 0, s0, s1);
    Load2Pixels(leftMostIndex + 1, s2, s3);
    Load2Pixels(leftMostIndex + 2, s4, s5);
    Load2Pixels(leftMostIndex + 3, s6, s7);
    Load2Pixels(leftMostIndex + 4, s8, s9);

    Store1Pixel(outIndex    , BlurPixels(s0, s1, s2, s3, s4, s5, s6, s7, s8));
    Store1Pixel(outIndex + 1, BlurPixels(s1, s2, s3, s4, s5, s6, s7, s8, s9));
}

void BlurVertically(uint2 pixelCoord, uint topMostIndex)
{
    float3 s0, s1, s2, s3, s4, s5, s6, s7, s8;
    Load1Pixel(topMostIndex     , s0);
    Load1Pixel(topMostIndex +  8, s1);
    Load1Pixel(topMostIndex + 16, s2);
    Load1Pixel(topMostIndex + 24, s3);
    Load1Pixel(topMostIndex + 32, s4);
    Load1Pixel(topMostIndex + 40, s5);
    Load1Pixel(topMostIndex + 48, s6);
    Load1Pixel(topMostIndex + 56, s7);
    Load1Pixel(topMostIndex + 64, s8);

    float3 blurred = BlurPixels(s0, s1, s2, s3, s4, s5, s6, s7, s8);

    // Guard bands
    blurred *= all(pixelCoord < uint2(_TexelSize.xy));

    // Write to the final target
    _OutputTexture[COORD_TEXTURE2D_X(pixelCoord)] = blurred;
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void BlurUnity(uint2 groupId : SV_GroupID, uint2 groupThreadId : SV_GroupThreadID, uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    // Upper-left pixel coordinate of quad that this thread will read
    int2 threadUL = (groupThreadId << 1) + (groupId << 3) - 4;

//#if DOWNSAMPLE
//    float2 offset = float2(threadUL);
//    float2 maxCoord = 1.0 - 0.5f *_TexelSize.zw;
//    float3 p00 = SAMPLE_TEXTURE2D_X_LOD(_InputTexture, sampler_LinearClamp, ClampAndScaleUVForBilinear((offset                    + 0.5) * _TexelSize.zw, _TexelSize.zw), 0.0).xyz;
//    float3 p10 = SAMPLE_TEXTURE2D_X_LOD(_InputTexture, sampler_LinearClamp, ClampAndScaleUVForBilinear((offset + float2(1.0, 0.0) + 0.5) * _TexelSize.zw, _TexelSize.zw), 0.0).xyz;
//    float3 p01 = SAMPLE_TEXTURE2D_X_LOD(_InputTexture, sampler_LinearClamp, ClampAndScaleUVForBilinear((offset + float2(0.0, 1.0) + 0.5) * _TexelSize.zw, _TexelSize.zw), 0.0).xyz;
//    float3 p11 = SAMPLE_TEXTURE2D_X_LOD(_InputTexture, sampler_LinearClamp, ClampAndScaleUVForBilinear((offset + float2(1.0, 1.0) + 0.5) * _TexelSize.zw, _TexelSize.zw), 0.0).xyz;
//#else
    uint2 uthreadUL = uint2(max(0, threadUL));
    uint2 size = uint2(_TexelSize.xy) - 1u;
    float3 p00 = _InputTexture[COORD_TEXTURE2D_X(min(uthreadUL + uint2(0u, 0u), size))].xyz;
    float3 p10 = _InputTexture[COORD_TEXTURE2D_X(min(uthreadUL + uint2(1u, 0u), size))].xyz;
    float3 p11 = _InputTexture[COORD_TEXTURE2D_X(min(uthreadUL + uint2(1u, 1u), size))].xyz;
    float3 p01 = _InputTexture[COORD_TEXTURE2D_X(min(uthreadUL + uint2(0u, 1u), size))].xyz;
//#endif

    // Store the 4 downsampled pixels in LDS
    uint destIdx = groupThreadId.x + (groupThreadId.y << 4u);
    Store2Pixels(destIdx     , p00, p10);
    Store2Pixels(destIdx + 8u, p01, p11);

    GroupMemoryBarrierWithGroupSync();

    // Horizontally blur the pixels in LDS
    uint row = groupThreadId.y << 4u;
    BlurHorizontally(row + (groupThreadId.x << 1u), row + groupThreadId.x + (groupThreadId.x & 4u));

    GroupMemoryBarrierWithGroupSync();

    // Vertically blur the pixels in LDS and write the result to memory
    BlurVertically(dispatchThreadId.xy, (groupThreadId.y << 3u) + groupThreadId.x);
}

//
//
// Horizontal blur
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void HBlur(uint3 dispatchThreadId : SV_DispatchThreadID)
{
	UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
	PositionInputs posInputs = GetPositionInput(float2(dispatchThreadId.xy), float2(1, 1), uint2(GROUP_SIZE, GROUP_SIZE));
	float2 positionSS = posInputs.positionNDC;
	//uint2 positionSS = COORD_TEXTURE2D_X(posInputs.positionSS).xy;

	float3 outColor = float3(0, 0, 0);
	float totalWeight = 0;
	for(int x = -_BlurSteps; x <= _BlurSteps; x++)
	{
		float posX = positionSS.x + x * _BlurStepSize;
		posX = max(1, posX);
		posX = min(_ScreenSize.x * _TexelSize.z - 1, posX);

		uint2 blurPos = uint2(posX, positionSS.y);

		float3 neighborColor = float3(0, 0, 0);
		neighborColor += LOAD_TEXTURE2D_X(_InputTexture, blurPos).xyz;

		float distance = abs(x) * _BlurStepSize;
		float weight = 1 - (distance / (_BlurSteps * _BlurStepSize));
		weight = max(0, weight);

		outColor += (neighborColor) * weight;
		totalWeight += weight;
	}

	outColor = (outColor / totalWeight);

	_OutputTexture[COORD_TEXTURE2D_X(posInputs.positionSS)] = outColor;
}

//
//
// Vertical blur
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void VBlur(uint3 dispatchThreadId : SV_DispatchThreadID)
{
	UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
	PositionInputs posInputs = GetPositionInput(float2(dispatchThreadId.xy), float2(1, 1), uint2(GROUP_SIZE, GROUP_SIZE));
	float2 positionSS = posInputs.positionNDC;
	//uint2 positionSS = COORD_TEXTURE2D_X(posInputs.positionSS).xy;

	float3 outColor = float3(0, 0, 0);
	float totalWeight = 0;

	for(int y = -_BlurSteps; y <= _BlurSteps; y++)
	{
		//int posX = positionSS.x + x * _BlurStepSize;
		int posY = positionSS.y + y * _BlurStepSize;
		//posX = max(1, posX);
		posY = max(1, posY);
		//posX = min(_ScreenSize.x - 1, posX);
		posY = min(_ScreenSize.y * _TexelSize.w - 1, posY);

		uint2 blurPos = uint2(positionSS.x, posY);

		float3 neighborColor = float3(0, 0, 0);
		neighborColor += LOAD_TEXTURE2D_X(_OutputTexture, blurPos).xyz;

		float distance = abs(y) * _BlurStepSize;
		float weight = 1 - (distance / (_BlurSteps * _BlurStepSize));
		weight = max(0, weight);

		outColor += (neighborColor) * weight;
		totalWeight += weight;
	}

	outColor = (outColor / totalWeight);

	_OutputTexture[COORD_TEXTURE2D_X(posInputs.positionSS)] = outColor;
}