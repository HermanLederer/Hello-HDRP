#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Filtering.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/BloomCommon.hlsl"

#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel UpsampleUnity
#pragma kernel UpsampleH
#pragma kernel Blur
#pragma kernel VBlur

TEXTURE2D_X(_InputTexture);
RW_TEXTURE2D_X(float3, _OutputTexture);
int _BlurSteps;
float _BlurStepSize;

SAMPLER(sampler_LinearClamp);

//CBUFFER_START(cb0)
    //float4 _Params;                 // x: scatter, yzw: unused
    float4 _BloomBicubicParams;     // xy: low src size, zw: low src texel size
    float4 _TexelSize;              // xy; high src size, zw: high src texel size
//CBUFFER_END

#define GROUP_SIZE 8

float random(float2 uv)
{
	return frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453123);
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void UpsampleUnity(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
    PositionInputs posInputs = GetPositionInput(float2(dispatchThreadId.xy), _TexelSize.zw, uint2(GROUP_SIZE, GROUP_SIZE));
    // float2 uv = ClampAndScaleUVForBilinear(posInputs.positionNDC, _TexelSize.zw);
    float2 uv = posInputs.positionNDC;

    //float3 lowRes = SAMPLE_TEXTURE2D_X_LOD(_InputTexture, sampler_LinearClamp, uv, 0.0).xyz;

    //float2 maxCoord = (1.0f - _TexelSize.zw) * _RTHandleScale.xy;
    //float3 lowRes = SampleTexture2DBicubic(TEXTURE2D_X_ARGS(_InputTexture, sampler_LinearClamp), uv, _BloomBicubicParams, maxCoord, unity_StereoEyeIndex).xyz;

    float3 output = LOAD_TEXTURE2D_X(_InputTexture, uv).xyz;

    // Guard bands
    //output *= all(dispatchThreadId.xy < uint2(_TexelSize.xy));

    //output += float3(1, 1, 1);
    _OutputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = output;
}

//
//
// Upsample
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void UpsampleH(uint3 dispatchThreadId : SV_DispatchThreadID)
{
	UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
	PositionInputs posInputs = GetPositionInput(float2(dispatchThreadId.xy), float2(1, 1), uint2(GROUP_SIZE, GROUP_SIZE));
	float2 positionSS = COORD_TEXTURE2D_X(posInputs.positionSS).xy;
	float2 uv = posInputs.positionNDC;

	//positionLeft = float2(positionSS.x - 1, positionSS.y);
	//positionRight = float2(positionSS.x + 1, positionSS.y);

	// Origin
	// Right (x + 1)
	// Down (y + 1)
	float3 outColor = LOAD_TEXTURE2D_X(_InputTexture, positionSS * _TexelSize.z).xyz;
	float totalWeight = 1;

	float3 outColorR = LOAD_TEXTURE2D_X(_InputTexture, positionSS * _TexelSize.z + float2(1, 0)).xyz;
	float3 outColorD = LOAD_TEXTURE2D_X(_InputTexture, positionSS * _TexelSize.z + float2(0, 1)).xyz;

	/*for(int x = 0; x <= 4; x++)
	{
		float posX = positionSS.x * _TexelSize.z + x;
		//int posY = positionSS.y + y * _BlurStepSize;
		posX = max(1, posX);
		//posY = max(1, posY);
		posX = min(_ScreenSize.x - 1, posX);
		//posY = min(_ScreenSize.y - 1, posY);

		uint2 blurPos = uint2(posX, positionSS.y);

		float3 neighborColor = float3(0, 0, 0);
		neighborColor += LOAD_TEXTURE2D_X(_InputTexture, blurPos).xyz;

		float distance = abs(x);
		float weight = 1 - (distance / (_BlurSteps * _BlurStepSize));
		weight = max(0, weight);

		outColor += (neighborColor) * weight;
		totalWeight += weight;
	}*/

	//float tx = (positionSS.x % _TexelSize.x) / 4;
	//float ty = (positionSS.y % _TexelSize.y) / 4;

	//_OutputTexture[COORD_TEXTURE2D_X(uv)] = lerp(outColor, outColorR, tx);
	//_OutputTexture[COORD_TEXTURE2D_X(uv)] = outColor;
	//_OutputTexture[COORD_TEXTURE2D_X(posInputs.positionSS)] = random(uv);
}

//
//
// Horizontal blur
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void Blur(uint3 dispatchThreadId : SV_DispatchThreadID)
{
	UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
	PositionInputs posInputs = GetPositionInput(float2(dispatchThreadId.xy), float2(1, 1), uint2(GROUP_SIZE, GROUP_SIZE));
	float2 positionSS = posInputs.positionNDC;
	positionSS *= float2(_TexelSize.z, 1);

	//float3 outColor = float3(0, 0, 0);
	float3 outColor = LOAD_TEXTURE2D_X(_InputTexture, positionSS).xyz;
	float totalWeight = 0;
	for(int x = -_BlurSteps; x <= _BlurSteps; x++)
	{
		float posX = positionSS.x + x * _BlurStepSize;
		//int posY = positionSS.y + y * _BlurStepSize;
		posX = max(1, posX);
		//posY = max(1, posY);
		posX = min(_ScreenSize.x - 1, posX);
		//posY = min(_ScreenSize.y - 1, posY);

		uint2 blurPos = uint2(posX, positionSS.y);

		float3 neighborColor = float3(0, 0, 0);
		neighborColor += LOAD_TEXTURE2D_X(_InputTexture, blurPos).xyz;

		float distance = abs(x);
		float weight = 1 - (distance / (_BlurSteps * _BlurStepSize));
		weight = max(0, weight);

		//outColor += (neighborColor) * weight;
		totalWeight += weight;
	}

	//outColor = (outColor / totalWeight);

	//_OutputTexture[COORD_TEXTURE2D_X(posInputs.positionSS)] = outColor;
}

//
//
// Vertical blur
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void VBlur(uint3 dispatchThreadId : SV_DispatchThreadID)
{
	UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
	PositionInputs posInputs = GetPositionInput(float2(dispatchThreadId.xy), float2(1, 1), uint2(GROUP_SIZE, GROUP_SIZE));
	uint2 positionSS = COORD_TEXTURE2D_X(posInputs.positionSS).xy;
	positionSS *= float2(1, _TexelSize.w);

	float3 outColor = LOAD_TEXTURE2D_X(_InputTexture, positionSS).xyz;
	float totalWeight = 1;

	/*for(int y = -_BlurSteps; y <= _BlurSteps; y++)
	{
		//int posX = positionSS.x + x * _BlurStepSize;
		int posY = positionSS.y + y * _BlurStepSize;
		//posX = max(1, posX);
		posY = max(1, posY);
		//posX = min(_ScreenSize.x - 1, posX);
		posY = min(_ScreenSize.y - 1, posY);

		uint2 blurPos = uint2(positionSS.x, posY);

		float3 neighborColor = float3(0, 0, 0);
		neighborColor += LOAD_TEXTURE2D_X(_OutputTexture, blurPos).xyz;

		float distance = abs(y);
		float weight = 1 - (distance / (_BlurSteps * _BlurStepSize));
		weight = max(0, weight);

		//outColor += (neighborColor) * weight;
		totalWeight += weight;
	}*/

	//outColor = (outColor / totalWeight);

	//_OutputTexture[COORD_TEXTURE2D_X(posInputs.positionSS)] = outColor;
}